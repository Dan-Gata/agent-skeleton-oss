const express = require('express');
const axios = require('axios');
const path = require('path');
const helmet = require('helmet');
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const { body, validationResult } = require('express-validator');
const cookieParser = require('cookie-parser');
const multer = require('multer');

// Import des services
const aiService = require('./services/aiService');
const { authService, requireAuth, requireAuthAPI } = require('./middleware/auth');
const { memoryService } = require('./services/memoryService');
const { socialWorkflowService } = require('./services/socialWorkflowService');
const fileService = require('./services/fileService');

const app = express();
const port = process.env.PORT || 3000;
    
    res.render('app', {
        title: 'Agent Skeleton OSS - Interface Moderne',
        version: '1.0.0',
        user: req.user,
        cacheBuster: Date.now() // Force le rechargement des assets
    });
});
const cors = require('cors');
const rateLimit = require('express-rate-limit');
const { body, validationResult } = require('express-validator');
const cookieParser = require('cookie-parser');
const multer = require('multer');

// Import des services
const aiService = require('./services/aiService');
const { authService, requireAuth, requireAuthAPI } = require('./middleware/auth');
const { memoryService } = require('./services/memoryService');
const { socialWorkflowService } = require('./services/socialWorkflowService');
const fileService = require('./services/fileService');

const app = express();
const port = process.env.PORT || 3000;

// ğŸ”’ SÃ‰CURITÃ‰ : Configuration des headers de sÃ©curitÃ©
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'", "https://cdnjs.cloudflare.com", "https://fonts.googleapis.com"],
            scriptSrc: ["'self'", "'unsafe-inline'"],
            fontSrc: ["'self'", "https://cdnjs.cloudflare.com", "https://fonts.gstatic.com"],
            imgSrc: ["'self'", "data:", "https:"],
            connectSrc: ["'self'"]
        }
    },
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    }
}));

// Configuration du moteur de templates
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '../views'));

// ğŸ”’ CORS Configuration
const allowedOrigins = process.env.ALLOWED_ORIGINS
    ? process.env.ALLOWED_ORIGINS.split(',')
    : ['http://localhost:3000'];

app.use(cors({
    origin: allowedOrigins,
    credentials: true,
    optionsSuccessStatus: 200
}));

// ğŸ”’ Rate Limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limite chaque IP Ã  100 requÃªtes par windowMs
    message: {
        error: 'Trop de requÃªtes depuis cette IP, rÃ©essayez plus tard.',
        retryAfter: '15 minutes'
    },
    legacyHeaders: false
});

const chatLimiter = rateLimit({
    windowMs: 1 * 60 * 1000, // 1 minute
    max: 10, // limite chaque IP Ã  10 requÃªtes de chat par minute
    message: {
        error: 'Trop de messages de chat, attendez avant de continuer.',
        retryAfter: '1 minute'
    }
});

app.use(limiter);

// Middleware pour parsing JSON et URL-encoded
app.use(cookieParser());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ğŸ“ Configuration Multer pour les uploads
const upload = multer({
    storage: multer.memoryStorage(),
    limits: {
        fileSize: 10 * 1024 * 1024, // 10MB
        files: 1
    },
    fileFilter: (req, file, cb) => {
        const allowedTypes = [
            'text/plain',
            'text/markdown',
            'application/json',
            'text/csv',
            'application/pdf',
            'image/jpeg',
            'image/png',
            'image/webp',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        ];
        
        if (allowedTypes.includes(file.mimetype)) {
            cb(null, true);
        } else {
            cb(new Error(`Type de fichier non autorisÃ©: ${file.mimetype}`), false);
        }
    }
});

// Fichiers statiques
app.use(express.static(path.join(__dirname, '../public')));

// ğŸ  Route principale - Interface moderne (protÃ©gÃ©e)
app.get('/', requireAuth, (req, res) => {
    res.render('app', {
        title: 'Agent Skeleton OSS',
        version: '1.0.0',
        user: req.user
    });
});

// ï¿½ Route de connexion (non protÃ©gÃ©e)
app.get('/login', (req, res) => {
    res.render('login', { title: 'Connexion - Agent Skeleton OSS' });
});

// ï¿½ğŸ“± Route pour l'interface moderne (protÃ©gÃ©e)
app.get('/app', requireAuth, (req, res) => {
    res.render('app', {
        title: 'Agent Skeleton OSS - Interface Moderne',
        version: '1.0.0',
        user: req.user
    });
});

// ğŸ” Routes d'authentification
app.post('/api/auth/register', [
    body('username').isLength({ min: 3 }).withMessage('Nom d\'utilisateur requis (min 3 caractÃ¨res)'),
    body('password').isLength({ min: 6 }).withMessage('Mot de passe requis (min 6 caractÃ¨res)'),
    body('email').isEmail().withMessage('Email valide requis')
], (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    try {
        const { username, password, email } = req.body;
        const result = authService.createAccount(username, password, email);
        res.json({ success: true, message: 'Compte crÃ©Ã© avec succÃ¨s' });
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

app.post('/api/auth/login', [
    body('username').notEmpty().withMessage('Nom d\'utilisateur requis'),
    body('password').notEmpty().withMessage('Mot de passe requis')
], (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    try {
        const { username, password } = req.body;
        const result = authService.login(username, password);
        
        // DÃ©finir le cookie de session
        res.cookie('sessionId', result.sessionId, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            maxAge: 24 * 60 * 60 * 1000 // 24 heures
        });

        res.json({ success: true, user: result.user });
    } catch (error) {
        res.status(401).json({ error: error.message });
    }
});

app.post('/api/auth/logout', requireAuthAPI, (req, res) => {
    const sessionId = req.cookies?.sessionId;
    if (sessionId) {
        authService.logout(sessionId);
        res.clearCookie('sessionId');
    }
    res.json({ success: true, message: 'DÃ©connexion rÃ©ussie' });
});

// ğŸ”§ Route de debug pour tester la navigation
app.get('/debug', (req, res) => {
    res.render('app_debug', {
        title: 'Agent Skeleton OSS - Debug Interface',
        version: '1.0.0'
    });
});

// ğŸ” Health Check
app.get('/health', (req, res) => {
    res.status(200).json({
        status: 'healthy',
        timestamp: new Date().toISOString(),
        version: '1.0.0',
        environment: process.env.NODE_ENV || 'development'
    });
});

// ğŸ”‘ API Keys Status Check (pour debug)
app.get('/api/keys-status', (req, res) => {
    const hasOpenRouter = !!process.env.OPENROUTER_API_KEY;
    const status = {
        openrouter: hasOpenRouter,
        all_models_available: hasOpenRouter,
        provider: 'OpenRouter (Unified API)',
        models: {
            'gpt-4o-mini': hasOpenRouter ? 'Available via OpenRouter' : 'Requires OpenRouter key',
            'claude-3.5-sonnet': hasOpenRouter ? 'Available via OpenRouter' : 'Requires OpenRouter key',
            'gemini-2.0-flash': hasOpenRouter ? 'Available via OpenRouter' : 'Requires OpenRouter key',
            'grok-beta': hasOpenRouter ? 'Available via OpenRouter' : 'Requires OpenRouter key'
        },
        demo_mode: !hasOpenRouter
    };
    
    res.json(status);
});

// ğŸ¤– ENDPOINTS AGENT AUTONOME

// ğŸ”„ n8n Workflows Management
app.get('/api/agent/n8n/status', async (req, res) => {
    try {
        if (!process.env.N8N_API_KEY || !process.env.N8N_API_URL) {
            return res.status(400).json({ 
                error: 'Configuration n8n manquante', 
                configured: false,
                message: 'Veuillez ajouter N8N_API_KEY et N8N_API_URL dans les variables d\'environnement Coolify'
            });
        }

        // VÃ©rifier la connexion Ã  n8n
        const response = await axios.get(`${process.env.N8N_API_URL}/api/v1/workflows`, {
            headers: {
                'X-N8N-API-KEY': process.env.N8N_API_KEY
            }
        });

        const workflows = response.data.data || [];
        
        // Analyser les workflows
        const activeWorkflows = workflows.filter(w => w.active);
        const inactiveWorkflows = workflows.filter(w => !w.active);

        res.json({
            success: true,
            configured: true,
            n8n_url: process.env.N8N_API_URL,
            status: {
                total_workflows: workflows.length,
                active_workflows: activeWorkflows.length,
                inactive_workflows: inactiveWorkflows.length,
                workflows: workflows.map(w => ({
                    id: w.id,
                    name: w.name,
                    active: w.active,
                    createdAt: w.createdAt,
                    updatedAt: w.updatedAt
                }))
            }
        });
    } catch (error) {
        console.error('Erreur n8n:', error.message);
        
        if (error.response?.status === 401) {
            return res.status(401).json({ 
                error: 'ClÃ© API n8n invalide', 
                configured: false,
                message: 'VÃ©rifiez votre N8N_API_KEY dans Coolify'
            });
        }
        
        res.status(500).json({ 
            error: 'Erreur connexion n8n', 
            details: error.message,
            configured: !!process.env.N8N_API_KEY
        });
    }
});

app.get('/api/agent/n8n/workflows', async (req, res) => {
    try {
        if (!process.env.N8N_API_KEY || !process.env.N8N_API_URL) {
            return res.status(400).json({ error: 'ClÃ©s n8n manquantes', configured: false });
        }
        
        // Simuler la rÃ©cupÃ©ration des workflows (remplacer par vraie API)
        const workflows = [
            { id: 1, name: 'Agent Chat Automation', active: true, lastExecution: '2025-10-07T10:30:00Z' },
            { id: 2, name: 'Baserow Sync', active: true, lastExecution: '2025-10-07T09:15:00Z' },
            { id: 3, name: 'Deploy Monitor', active: false, lastExecution: '2025-10-06T22:00:00Z' }
        ];
        
        res.json({ workflows, configured: true });
    } catch (error) {
        res.status(500).json({ error: 'Erreur n8n', details: error.message });
    }
});

app.get('/api/agent/n8n/executions', async (req, res) => {
    try {
        if (!process.env.N8N_API_KEY || !process.env.N8N_API_URL) {
            return res.status(400).json({ error: 'Configuration n8n manquante', configured: false });
        }

        // RÃ©cupÃ©rer les exÃ©cutions rÃ©centes
        const response = await axios.get(`${process.env.N8N_API_URL}/api/v1/executions`, {
            headers: {
                'X-N8N-API-KEY': process.env.N8N_API_KEY
            },
            params: {
                limit: 20,
                includeData: false
            }
        });

        const executions = response.data.data || [];
        
        // Analyser les exÃ©cutions
        const successful = executions.filter(e => e.finished && !e.stoppedAt).length;
        const failed = executions.filter(e => e.stoppedAt && e.stoppedAt !== e.finishedAt).length;
        const running = executions.filter(e => !e.finished).length;

        res.json({
            success: true,
            executions: executions.map(e => ({
                id: e.id,
                workflowId: e.workflowId,
                mode: e.mode,
                finished: e.finished,
                startedAt: e.startedAt,
                finishedAt: e.finishedAt,
                stoppedAt: e.stoppedAt
            })),
            stats: {
                total: executions.length,
                successful,
                failed,
                running
            }
        });
    } catch (error) {
        res.status(500).json({ error: 'Erreur rÃ©cupÃ©ration exÃ©cutions', details: error.message });
    }
});

app.post('/api/agent/n8n/create-workflow', async (req, res) => {
    try {
        const { name, description, trigger, actions } = req.body;
        
        // Simuler la crÃ©ation d'un workflow
        const newWorkflow = {
            id: Date.now(),
            name: name || 'Nouveau Workflow',
            description: description || 'CrÃ©Ã© par Agent Skeleton OSS',
            active: false,
            created: new Date().toISOString()
        };
        
        res.json({ 
            success: true, 
            workflow: newWorkflow,
            message: `Workflow "${newWorkflow.name}" crÃ©Ã© avec succÃ¨s` 
        });
    } catch (error) {
        res.status(500).json({ error: 'Erreur crÃ©ation workflow', details: error.message });
    }
});

// ğŸš€ Coolify Deployments Management  
app.get('/api/agent/coolify/deployments', async (req, res) => {
    try {
        if (!process.env.COOLIFY_API_KEY || !process.env.COOLIFY_API_URL) {
            return res.status(400).json({ error: 'ClÃ©s Coolify manquantes', configured: false });
        }
        
        // Simuler l'Ã©tat des dÃ©ploiements
        const deployments = [
            { id: 1, name: 'agent-skeleton-oss', status: 'running', lastDeploy: '2025-10-07T11:00:00Z', health: 'healthy' },
            { id: 2, name: 'n8n-instance', status: 'running', lastDeploy: '2025-10-07T08:30:00Z', health: 'healthy' },
            { id: 3, name: 'baserow-db', status: 'stopped', lastDeploy: '2025-10-06T20:15:00Z', health: 'warning' }
        ];
        
        res.json({ deployments, configured: true });
    } catch (error) {
        res.status(500).json({ error: 'Erreur Coolify', details: error.message });
    }
});

app.post('/api/agent/coolify/deploy', async (req, res) => {
    try {
        const { serviceId, serviceName } = req.body;
        
        // Simuler un dÃ©ploiement
        const deployment = {
            id: serviceId || Date.now(),
            name: serviceName || 'Service inconnu',
            status: 'deploying',
            startedAt: new Date().toISOString()
        };
        
        res.json({ 
            success: true, 
            deployment,
            message: `DÃ©ploiement de "${deployment.name}" initiÃ©` 
        });
    } catch (error) {
        res.status(500).json({ error: 'Erreur dÃ©ploiement', details: error.message });
    }
});

// ğŸ“Š Baserow Database Management
app.get('/api/agent/baserow/tables', async (req, res) => {
    try {
        if (!process.env.BASEROW_API_KEY || !process.env.BASEROW_URL) {
            return res.status(400).json({ error: 'ClÃ©s Baserow manquantes', configured: false });
        }
        
        // Simuler les tables Baserow
        const tables = [
            { id: 1, name: 'Conversations', rows: 156, lastUpdate: '2025-10-07T10:45:00Z' },
            { id: 2, name: 'Workflows Status', rows: 3, lastUpdate: '2025-10-07T09:30:00Z' },
            { id: 3, name: 'Deployments Log', rows: 42, lastUpdate: '2025-10-07T11:00:00Z' }
        ];
        
        res.json({ tables, configured: true });
    } catch (error) {
        res.status(500).json({ error: 'Erreur Baserow', details: error.message });
    }
});

app.post('/api/agent/baserow/sync', async (req, res) => {
    try {
        const { tableId, action } = req.body;
        
        // Simuler une synchronisation
        const syncResult = {
            tableId: tableId || 1,
            action: action || 'sync',
            recordsProcessed: Math.floor(Math.random() * 50) + 10,
            status: 'completed',
            timestamp: new Date().toISOString()
        };
        
        res.json({ 
            success: true, 
            result: syncResult,
            message: `Synchronisation rÃ©ussie : ${syncResult.recordsProcessed} enregistrements traitÃ©s` 
        });
    } catch (error) {
        res.status(500).json({ error: 'Erreur synchronisation', details: error.message });
    }
});

// ğŸ­ Routes pour les workflows de rÃ©seaux sociaux
app.post('/api/agent/social/create-publisher', requireAuthAPI, async (req, res) => {
    try {
        const { platforms, autoPost } = req.body;
        const userId = req.user.userId;
        
        const result = await socialWorkflowService.createSocialPublishingWorkflow(
            userId, 
            platforms || ['facebook', 'twitter', 'linkedin']
        );
        
        if (result.success) {
            memoryService.saveConversation(userId, 
                `CrÃ©er un workflow de publication sociale pour ${platforms?.join(', ')}`,
                `Workflow de publication crÃ©Ã© avec succÃ¨s pour les plateformes: ${platforms?.join(', ')}`,
                'system',
                { workflowId: result.workflowId, action: 'create_social_workflow' }
            );
        }
        
        res.json(result);
    } catch (error) {
        res.status(500).json({ error: 'Erreur crÃ©ation workflow social', details: error.message });
    }
});

app.post('/api/agent/social/create-monitor', requireAuthAPI, async (req, res) => {
    try {
        const { keywords, platforms } = req.body;
        const userId = req.user.userId;
        
        const result = await socialWorkflowService.createSocialMonitoringWorkflow(
            userId,
            keywords || []
        );
        
        if (result.success) {
            memoryService.saveConversation(userId,
                `CrÃ©er un monitoring social pour: ${keywords?.join(', ')}`,
                `Workflow de monitoring crÃ©Ã© pour surveiller: ${keywords?.join(', ')}`,
                'system',
                { workflowId: result.workflowId, action: 'create_monitor_workflow' }
            );
        }
        
        res.json(result);
    } catch (error) {
        res.status(500).json({ error: 'Erreur crÃ©ation monitoring social', details: error.message });
    }
});

// ğŸ§  Routes de mÃ©moire pour l'agent
app.get('/api/agent/memory/conversations', requireAuthAPI, (req, res) => {
    try {
        const userId = req.user.userId;
        const limit = parseInt(req.query.limit) || 20;
        
        const conversations = memoryService.getConversationHistory(userId, limit);
        res.json({ conversations, count: conversations.length });
    } catch (error) {
        res.status(500).json({ error: 'Erreur rÃ©cupÃ©ration mÃ©moire', details: error.message });
    }
});

// ğŸ’¬ API Chat avec validation, rate limiting et mÃ©moire
app.post('/api/chat', chatLimiter, requireAuthAPI, async (req, res) => {
    try {
        console.log('ğŸ” DonnÃ©es reÃ§ues brutes:', req.body);
        
        const { message, conversationId, model } = req.body;
        
        // Validation simple manuelle
        if (!message || typeof message !== 'string' || message.trim().length === 0) {
            console.log('âŒ Message invalide:', message);
            return res.status(400).json({
                error: 'Message requis',
                details: 'Le message ne peut pas Ãªtre vide'
            });
        }

        console.log('âœ… Message valide reÃ§u:', { message, conversationId, model });
        
        // Debug des clÃ©s API (OpenRouter uniquement)
        console.log('ğŸ”‘ Ã‰tat OpenRouter:', {
            OPENROUTER_KEY: !!process.env.OPENROUTER_API_KEY,
            ALL_MODELS: !!process.env.OPENROUTER_API_KEY ? 'Available' : 'Demo Mode'
        });

        // Responses basÃ©es sur le modÃ¨le sÃ©lectionnÃ©
        const modelResponses = {
            'claude-3.5-sonnet': [
                "ğŸ§  Claude 3.5 Sonnet ici ! Je vais analyser votre demande avec attention.",
                "ğŸ” Excellente question ! Avec Claude, je peux vous aider Ã  explorer cette idÃ©e en profondeur.",
                "ğŸ’¡ En tant que Claude 3.5 Sonnet, je propose une approche mÃ©thodique pour rÃ©soudre cela.",
                "ğŸ“Š GrÃ¢ce aux capacitÃ©s de Claude, voici une analyse dÃ©taillÃ©e de votre demande.",
                "ğŸ¯ Claude 3.5 Sonnet est conÃ§u pour vous fournir des rÃ©ponses nuancÃ©es et pertinentes."
            ],
            'gpt-4': [
                "ï¿½ GPT-4 activÃ© ! Je vais traiter votre requÃªte avec ma comprÃ©hension avancÃ©e.",
                "âš¡ Excellent ! GPT-4 est parfait pour ce type de question complexe.",
                "ğŸ­ Avec GPT-4, je peux aborder votre demande sous plusieurs angles crÃ©atifs.",
                "ï¿½ Utilisant les capacitÃ©s de GPT-4, voici une rÃ©ponse structurÃ©e pour vous.",
                "ğŸŒŸ GPT-4 me permet de vous offrir une perspective riche et dÃ©taillÃ©e."
            ],
            'gemini-pro': [
                "ğŸ’ Gemini Pro en action ! Analysons cela ensemble de maniÃ¨re intelligente.",
                "ğŸŒˆ Avec Gemini Pro, j'apporte une approche multimodale Ã  votre question.",
                "ğŸ”® Gemini Pro me donne la flexibilitÃ© pour explorer votre demande crÃ©ativement.",
                "â­ GrÃ¢ce Ã  Gemini Pro, je peux connecter diffÃ©rents concepts pour vous aider.",
                "ï¿½ Gemini Pro excelle dans la comprÃ©hension nuancÃ©e de votre demande."
            ]
        };

        // RÃ©ponses gÃ©nÃ©riques pour les autres modÃ¨les
        const genericResponses = [
            `ğŸ¤– ${model || 'IA'} : Votre message est bien reÃ§u ! Comment puis-je vous aider davantage ?`,
            `ğŸ’­ Avec ${model || 'ce modÃ¨le'}, je traite votre demande avec soin.`,
            `ğŸ”§ ${model || 'Le systÃ¨me'} analyse votre question et prÃ©pare une rÃ©ponse adaptÃ©e.`,
            `ğŸ“ Utilisant ${model || 'les capacitÃ©s IA'}, voici ma rÃ©flexion sur votre demande.`,
            `ğŸ¯ ${model || 'L\'assistant'} est prÃªt Ã  vous accompagner dans cette tÃ¢che.`
        ];

        // RÃ©cupÃ©rer le contexte de mÃ©moire pour l'utilisateur
        const personalizedContext = memoryService.generatePersonalizedContext(req.user.userId);
        
        // Appel du service IA rÃ©el avec contexte personnalisÃ© et accÃ¨s aux fichiers
        const aiResponse = await aiService.sendMessage(message, model, conversationId, personalizedContext, req.user.userId);
        
        console.log('ğŸ¤– RÃ©ponse IA reÃ§ue:', aiResponse);

        // Sauvegarder la conversation dans la mÃ©moire
        memoryService.saveConversation(req.user.userId, message, aiResponse.response, model, {
            simulated: aiResponse.simulated,
            conversationId: conversationId
        });

        // Apprendre des prÃ©fÃ©rences utilisateur
        memoryService.learnFromConversation(req.user.userId, message, aiResponse.response);

        // Si c'est une simulation, on ajoute un indicateur
        let finalResponse = aiResponse.response;
        if (aiResponse.simulated) {
            finalResponse = `${aiResponse.response}\n\nğŸ’¡ *Mode dÃ©mo - Configurez vos clÃ©s API pour activer l'IA complÃ¨te*`;
        } else if (aiResponse.error) {
            finalResponse = aiResponse.response;
        }

        res.json({
            response: finalResponse,
            conversationId: conversationId || `conv_${Date.now()}`,
            timestamp: new Date().toISOString(),
            model: model || 'assistant',
            usage: aiResponse.usage || null,
            simulated: aiResponse.simulated || false
        });

    } catch (error) {
        console.error('Erreur API Chat:', error);
        res.status(500).json({
            error: 'Erreur interne du serveur',
            message: 'Une erreur est survenue lors du traitement de votre message'
        });
    }
});

// ï¿½ API Gestion des fichiers

// Upload d'un fichier
app.post('/api/files/upload', requireAuthAPI, upload.single('file'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: 'Aucun fichier fourni' });
        }

        const userId = req.user.id;
        const metadata = await fileService.saveFile(req.file, userId);
        
        // Analyser le fichier pour l'agent
        const analysis = await fileService.analyzeForAgent(metadata.id);
        
        // Stocker dans la mÃ©moire de l'agent
        memoryService.addUserPreference(userId, 'uploaded_files', {
            fileId: metadata.id,
            analysis: analysis,
            uploadedAt: new Date().toISOString()
        });

        res.json({
            success: true,
            file: {
                id: metadata.id,
                originalName: metadata.originalName,
                size: metadata.size,
                type: metadata.mimeType
            },
            analysis: analysis.analysis,
            message: 'âœ… Fichier tÃ©lÃ©chargÃ© et analysÃ© par l\'agent'
        });
    } catch (error) {
        console.error('âŒ Erreur upload:', error);
        res.status(500).json({ 
            error: 'Erreur lors du tÃ©lÃ©chargement', 
            details: error.message 
        });
    }
});

// Lister les fichiers de l'utilisateur
app.get('/api/files', requireAuthAPI, async (req, res) => {
    try {
        const userId = req.user.id;
        const files = await fileService.listUserFiles(userId);
        res.json({ files });
    } catch (error) {
        console.error('âŒ Erreur listage fichiers:', error);
        res.status(500).json({ error: 'Erreur rÃ©cupÃ©ration fichiers' });
    }
});

// RÃ©cupÃ©rer le contenu d'un fichier
app.get('/api/files/:fileId', requireAuthAPI, async (req, res) => {
    try {
        const userId = req.user.id;
        const { fileId } = req.params;
        
        const metadata = await fileService.getFileMetadata(fileId);
        if (!metadata || metadata.uploadedBy !== userId) {
            return res.status(404).json({ error: 'Fichier non trouvÃ©' });
        }

        const content = await fileService.readFileContent(fileId);
        res.json({ content });
    } catch (error) {
        console.error('âŒ Erreur lecture fichier:', error);
        res.status(500).json({ error: 'Erreur lecture fichier' });
    }
});

// Analyser un fichier pour l'agent
app.post('/api/files/:fileId/analyze', requireAuthAPI, async (req, res) => {
    try {
        const userId = req.user.id;
        const { fileId } = req.params;
        
        const metadata = await fileService.getFileMetadata(fileId);
        if (!metadata || metadata.uploadedBy !== userId) {
            return res.status(404).json({ error: 'Fichier non trouvÃ©' });
        }

        const analysis = await fileService.analyzeForAgent(fileId);
        
        // Mettre Ã  jour la mÃ©moire
        memoryService.addUserPreference(userId, 'file_analysis', {
            fileId: fileId,
            analysis: analysis,
            analyzedAt: new Date().toISOString()
        });

        res.json({
            analysis: analysis.analysis,
            message: 'ğŸ¤– Fichier analysÃ© et intÃ©grÃ© Ã  la mÃ©moire de l\'agent'
        });
    } catch (error) {
        console.error('âŒ Erreur analyse fichier:', error);
        res.status(500).json({ error: 'Erreur analyse fichier' });
    }
});

// Supprimer un fichier
app.delete('/api/files/:fileId', requireAuthAPI, async (req, res) => {
    try {
        const userId = req.user.id;
        const { fileId } = req.params;
        
        await fileService.deleteFile(fileId, userId);
        
        res.json({ 
            success: true, 
            message: 'ğŸ—‘ï¸ Fichier supprimÃ© avec succÃ¨s' 
        });
    } catch (error) {
        console.error('âŒ Erreur suppression fichier:', error);
        res.status(500).json({ error: 'Erreur suppression fichier' });
    }
});

// ï¿½ğŸ“ API Instructions personnalisÃ©es
app.get('/api/instructions', (req, res) => {
    res.json({
        instructions: aiService.customInstructions
    });
});

app.post('/api/instructions', [
    body('brand').optional().isString().trim(),
    body('tone').optional().isString().trim(),
    body('expertise').optional().isString().trim(),
    body('language').optional().isString().trim(),
    body('personality').optional().isString().trim()
], (req, res) => {
    try {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({
                error: 'DonnÃ©es invalides',
                details: errors.array()
            });
        }

        // Filtrer les champs non-null
        const newInstructions = {};
        ['brand', 'tone', 'expertise', 'language', 'personality'].forEach(field => {
            if (req.body[field] !== undefined && req.body[field] !== '') {
                newInstructions[field] = req.body[field];
            }
        });

        // Mettre Ã  jour les instructions
        aiService.updateInstructions(newInstructions);

        res.json({
            success: true,
            instructions: aiService.customInstructions,
            message: 'Instructions mises Ã  jour avec succÃ¨s'
        });

    } catch (error) {
        console.error('Erreur API Instructions:', error);
        res.status(500).json({
            error: 'Erreur interne du serveur',
            message: 'Une erreur est survenue lors de la mise Ã  jour'
        });
    }
});

// ğŸ“Š API Status
app.get('/api/status', (req, res) => {
    res.json({
        status: 'online',
        version: '1.0.0',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        environment: process.env.NODE_ENV || 'development'
    });
});

// ğŸ”§ Middleware de gestion d'erreurs
app.use((err, req, res, next) => {
    console.error('Erreur:', err);
    res.status(500).json({
        error: 'Erreur interne du serveur',
        message: process.env.NODE_ENV === 'development' ? err.message : 'Une erreur est survenue'
    });
});

// 404 Handler
app.use((req, res) => {
    res.status(404).json({
        error: 'Page non trouvÃ©e',
        message: `La route ${req.originalUrl} n'existe pas`
    });
});

// DÃ©marrage du serveur
app.listen(port, () => {
    console.log(`ğŸš€ Agent Skeleton OSS dÃ©marrÃ© sur le port ${port}`);
    console.log(`ğŸŒ Interface disponible : http://localhost:${port}/app`);
    console.log(`ğŸ’š Health check : http://localhost:${port}/health`);
    console.log(`ğŸ“¡ API Status : http://localhost:${port}/api/status`);
});

module.exports = app;